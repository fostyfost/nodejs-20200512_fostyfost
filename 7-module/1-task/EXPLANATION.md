# Аутентификация/Авторизация

Любой процесс аутентификации/авторизации можно разбить на три этапа:

1. Получение данных пользователя либо от самого пользователя, например, логин и пароль, 
либо от социальной сети, если вход выполняется через нее.
1. Проверка полученных данных.
1. Принятие решение подходит ли нам этот пользователь.

При использовании модуля `passport` этот процесс определяется в сущности под названием «стратегия».

Официальная документация к модулю `passport` доступна на [официальном сайте](http://www.passportjs.org/).

## OAuth 2.0

[Протокол OAuth 2.0](https://oauth.net/2/) специально создан для решения ситуаций, 
когда одно приложение хочет получить доступ к данным пользователя, которые находятся у другого приложения. 
Один из самых частых случаев использования – это получение сторонним сайтом у социальной сети информации 
о ее пользователе: имя, почтовый адрес, аватар и т.д. Наверняка вы пользовались этой удобной возможностью, 
не вводя множество раз на разных сайтах данные для регистрации мы можем использовать профиль социальной сети, 
дав права тому или иному сайту получить их самостоятельно и использовать для регистрации.

Огромное количество готовых стратегий позволяет нам очень легко подключать любые социальные сети, 
через которые пользователь сможет зарегистрироваться или залогиниться на нашем сайте.

## Сессии

Сессия – это объект, который хранится на сервере (обычно в памяти или базе данных), 
и который ассоциирован с конкретным пользователем. Когда пользователь делает запрос он предоставляет ключ сессии, 
и мы таким образом получаем возможность хранить и использовать информацию о нем (например, 
кол-во заходов на страницу, товары, добавленные в избранное и т.д.). Если пользователь заходит впервые – то для него 
генерируется новый объект сессии и передается новый ключ.

Концепция сессий не связана с конкретными технологиями, все, что описано выше может быть успешно использовано 
при использовании любых языков программирования, фреймворков, даже сетевых протоколов. 
Традиционно при разработке веб-приложений для передачи ключа сессии используются `cookie` браузера. 
Это позволяет удобно создавать, читать и менять ключ, без необходимости уведомлять об этом клиента.

Однако `cookie` работают хорошо лишь в условиях «традиционных» веб-приложений, когда сервер генерирует HTML, 
который затем отображается браузером. В современных реалиях, клиентом далеко не всегда 
выступает браузер – это может быть и iOS, и Android приложение, да и сам браузер перестал быть просто средством 
отображения HTML, все чаще и чаще рендеринг происходит целиком на клиенте. 
В этих случаях передача ключа сессии выполняется «явно», т.е. клиент должен хранить ключ у себя и передавать 
на сервер с каждым запросом, чтобы сервер мог понять что за пользователь сделал запрос.

## Настройка локальной стратегии

В [официальной документации](https://github.com/jaredhanson/passport-local#usage) мы видим, 
что конструктор стратегии принимает 2 аргумента – объект с опциями, а также функцию, 
которая проверяет переданные пользователем значения логина и пароля.

Стоит отметить, что любой результат должен быть возвращен из этой функции с помощью коллбека `done`. 
Важно понять и запомнить аргументы этой функции:

1. `err` – это первый аргумент, который означает, что в процессе выполнения проверки произошла серьезная ошибка, 
не связанная с логикой проверки. Например, пропало соединение с базой данных.
1. `user` – второй аргумент может содержать либо объект пользователя (если все прошло хорошо), либо значение `false`, 
которое будет означать, что какие-то из проверок не пройдены.
1. `info` – это опциональный третий аргумент, в котором мы можем вернуть дополнительную информацию о результатах 
проверки, например, логин или пароль неверные.

Сама логика проверки в нашем случае будет выглядеть следующим образом:

1. Попытаемся найти пользователя по `email` с помощью модели `User` и ее метода `findOne`.
1. Если пользователя нет – вернем с помощью коллбека `done` сообщение, что пользователь не найден.
1. Если пользователь найден, то проверим его пароль с помощью метода `checkPassword`.
1. Если пароль неверный – вернем с помощью коллбека done сообщение, что пароль неверный.
1. Если пользователь передал верную пару `email:password`, то передадим в коллбек `done` вторым аргументом 
объект пользователя.

Для удобства работы с асинхронными методами `.findOne` и `.checkPassword` 
в стратегии можно использовать `async/await`:

```js

const LocalStrategy = require('passport-local').Strategy;
const User = require('../../models/User');

module.exports = new LocalStrategy(
  { usernameField: 'email', session: false, },
  async function(email, password, done) {
    try {
      const user = await User.findOne({email});
      if (!user) {
        return done(null, false, 'Нет такого пользователя');
      }

      const isValidPassword = await user.checkPassword(password);

      if (!isValidPassword) {
        return done(null, false, 'Неверный пароль');
      }

      return done(null, user);
    } catch (err) {
      done(err);
    }
  }
);

```
