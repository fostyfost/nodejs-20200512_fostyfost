# Tasks

Задачник для курса по Node.JS 
на сайте [https://learn.javascript.ru/courses/nodejs](https://learn.javascript.ru/courses/nodejs).

Содержит теоретические материалы и практические задания.

# 0-module 1-task: Сумма двух чисел

Для решения исходной задачи удобнее всего ее разбить на две подзадачи:

1. Написать код, который будет суммировать два числа.
1. Написать код, который будет проверять типы передаваемых значений.

## Суммирование двух чисел

Для получения суммы двух чисел воспользуемся оператором +, таким образом наш код будет
выглядеть так:

```js

// sum.js
function sum(a, b) {
  return a + b;
}

module.exports = sum;

```

Если мы теперь выполним тесты с помощью команды `npm run test:local 0-module 1-task`, то увидим,
что первый тест (проверяющий сумму чисел) – пройдет, значит наша первая подзадача решена успешно.


## Проверка типов

Однако остается вторая подзадача из условия – проверка типов передаваемых значений.
Нам необходимо удостовериться, что оба аргумента – числа.

Для проверки типа в JS существует операция typeof.
Применяя ее к аргументу мы получим строку, которая будет содержать имя типа передаваемого числа.
В данной задаче нам важно лишь проверить, что typeof от обоих аргументов – 'number''.
Если строка будет другой (нам неважно в данной задаче какой именно) – нам необходимо
бросить ошибку TypeError. В результате код будет выглядеть таким образом:

```js

function sum(a, b) {
  if ([a, b].some((value) => typeof value !== 'number')) {
    throw new TypeError();
  }

  return a + b;
}

module.exports = sum;

```

Теперь оба теста проходят – мы нашли решение задачи и можем отправлять его на проверку.

# 1-module 1-task: Событийный цикл

Полезные ссылки на статьи и видео по теме событийного цикла:

1. [https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop) (русский)
1. [https://www.youtube.com/watch?v=8aGhZQkoFbQ](https://www.youtube.com/watch?v=8aGhZQkoFbQ) (английский)
1. [https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules) (английский)

Более продвинутая версия, раскрывающая некоторые нюансы реализации в движке V8:

1. https://v8.dev/blog/fast-async (английский)

## Порядок вывода сообщений в консоль

Понимание того, как именно выполняется тот или иной код на Javascript – чрезвычайно важное
качество, отличающее действительно хороших разработчиков.

Выполнение любой программы на Javascript «раскладывается» на итерации событийного цикла.
В данной задаче у всех таймеров и интервалов установлена одинаковая ненулевая задержка в 10 мс,
это сделано для того, чтобы нам проще было «выполнять» код, подразумевая,
что коллбеки всех операций будут выполняться в том порядке, в котором и были созданы.
В реальной жизни операции имеют разное время выполнения, разную сложность и иногда даже разный
приоритет, но принципиально это ничего не меняет.

Ключ к пониманию происходящего поможет концепция очередей задач и микрозадач.
В очередь задач помещаются операции, коллбеки от которых будут выполнены на следующих итерациях
событийного цикла (`setTimeout`, `fs.readFile` и т.д.), а в очередь микрозадач – асинхронные
операции, выполнение коллбеков которых произойдет в конце текущей итерации, после синхронного кода.
Это, например: `Promise`, `process.nextTick`.

Таким образом, любой код можно мысленно разложить на итерации событийного цикла.

Давайте приступим к разбору исходного кода.

Для выполнения кода представим две очереди – два массива для задач (`tasks = []`)
и микрозадач (`microtasks = []`).

Начинается первая итерация событийного цикла, ее инициировал процесс Node.JS.
На строке 1 мы видим операцию `setInterval`, в результате которой через каждые 10мс
в консоль будет выводиться имя `"James"`. Мы знаем, что коллбек этой операции не будет выполнен
сразу же, а будет добавлен в очередь задач.

```js

tasks = [setInterval];
microtasks = [];

```

Далее на строке 5 операция `setTimeout`, коллбек которой также попадет в очередь задач
после `setInterval`. Сам код внутри коллбека `setTimeout` мы рассмотрим, когда он будет вызван.

```js

tasks = [setInterval, setTimeout];
microtasks = [];

```

К текущему моменту мы выполнили весь синхронный код, который был, очередь `microtasks` пуста,
поэтому происходит завершение текущей итерации событийного цикла.

Первая задача в очереди задач начинает собой следующую итерацию событийного цикла.
В данном случае будет выполнена функция, переданная в `setInterval`.
Мы видим, что в результате в консоль попадет строка `"James"`, после этого итерация
будет завершена. Коллбек операции `setInterval` попадет вновь в конец
очереди `tasks`.

```js

tasks = [setTimeout, setInterval];
microtasks = [];

// -- console
// James

```

Каждая новая итерация начинается с очередной задачи в очереди задач,
а данный момент мы видим там коллбек функции `setTimeout`.

Первым делом в этой функции создается объект `Promise`. В процессе создания функция,
которая передается в конструктор – выполняется синхронно, т.е. в консоль попадет строка `"Richard"`,
а коллбек метода `.then` попадет в очередь `microtasks`. Код, который следует
за объявлением коллбека `.then` и выводит в консоль `"John"` – синхронный.

```js

tasks = [setInterval];
microtasks = [Promise.then];

// -- console
// James
// Richard
// John

```

Теперь, прежде чем проверить очередь `tasks` процесс проверит, пуста ли очередь `microtasks`.
**Переход к следующей итерации событийного цикла не произойдет, пока выполняется синхронный код
или пока в очереди `microtasks` что-то есть!**

Мы видим, что в процессе выполнения коллбека функции `Promise.then` в консоль будет выведено
имя `Robert`, а также в очередь задач попадет новый таймер.

```js

tasks = [setInterval, setTimeout];
microtasks = [];

// -- console
// James
// Richard
// John
// Robert

```

По аналогии с предыдущими шагами мы знаем, что в данный момент произойдет завершение
текущей итерации, и функции из очереди `tasks` будут вызваны на следующих итерациях.
Таким образом в консоли мы увидим следующий вывод:

```js

// -- console
// James
// Richard
// John
// Robert
// James
// Michael

```

# Стримы в Node.JS

Материалы по теме стримов:

1. [https://nodejs.org/dist/latest/docs/api/stream.html](
https://nodejs.org/dist/latest/docs/api/stream.html) (английский, официальная документация)

## 2-module 1-task: Стрим с лимитом передачи данных

Для решения этой задачи нам надо в первую очередь посмотреть 
[https://nodejs.org/docs/latest/api/stream.html#stream_implementing_a_transform_stream](раздел документации), 
который описывает процесс создания собственных классов `Transform` стримов. 
Наша задача сводится к тому, чтобы реализовать метод `_tranform`, который будет вызываться каждый раз, когда очередная 
порция данных будет передаваться через стрим.

Этот метод получает следующий список параметров:

1. `chunk`: данные, которые передаются через стрим. 
Это может быть строка или специальный объект `Buffer`. 
В нашей задаче тип этого параметра не важен – прочитав свойство `.length` мы сможем получить размер передаваемых данных,
какого бы типа они не были.
1. `encoding`: кодировка данных, которую мы использовать не будем, т.к. в данной задаче она неважна.
1. `callback`: это функция обратного вызова, которая должна быть вызвана после того, 
как будут выполнены все действия по подсчету размера данных. Эта функция принимает два аргумента:
   1. объект ошибки, если что-то пошло не так (или `null`, если все в порядке).
   1. данные, в нашем случае это исходный параметр `chunk`.

Для того, чтобы следить за тем, сколько данных уже было передано через стрим создадим свойство `size` 
и будем увеличивать его каждый раз при вызове метода `_transform`.

В свойстве `limit` сохраним значение лимита, которое передается при создании стрима.

Если при очередном вызове значение свойства `size` превысит `limit` нам необходимо вызвать функцию `callback`, 
передав туда в качестве первого аргумента инстанс ошибки `LimitExceededError`.

В результате получится следующий код:

```js

const stream = require('stream');
const LimitExceededError = require('./LimitExceededError');

class LimitSizeStream extends stream.Transform {
  constructor(options) {
    super(options);

    this.limit = options.limit;
    this.size = 0;
  }

  _transform(chunk, encoding, callback) {
    this.size += chunk.length;

    if (this.size > this.limit) {
      callback(new LimitExceededError());
    } else {
      callback(null, chunk);
    }
  }
}

module.exports = LimitSizeStream;

```

Это и есть решение исходной задачи. Отдельно стоит отметить метод `_flush`, указанный в документации. 
Он не является обязательным для определения в нашем классе стрима, 
но может быть очень полезным если после окончания работы стрима нужно высвободить какие-то ресурсы 
(если стрим считывает данные из какого-то источника, например).

## Объектный режим

Это дополнительное условие задачи, которое необязательно к выполнению, 
однако является довольно важным для полноценного понимания как устроена работа со стримами в Node.JS.

По умолчанию стримы умеют работать либо со строками, либо с бинарными данными, 
но порой может быть полезно передавать через стримы объекты, например, когда нашей задачей является парсинг 
огромного JSON, содержащего массив с объектами. 
В этом случае стрим может быть переведен в объектный режим с помощью опции `objectMode: true`.

Наша текущая реализация при передаче объекта попытается получить у него свойство `.length` 
и прибавить его к значению свойства `size`. Логика работы в этом случае будет нарушена, 
так как мы должны считать каждый чанк за отдельно взятый объект и прибавлять к значению `size` единицу.

Для Transform и Duplex стримов, опций передается две: `readableObjectMode: true`, `writableObjectMode: true`, 
так как они содержат внутри и стрим для чтения, и стрим для записи.

Давайте проверять передается ли опция `readableObjectMode` при создании объекта, 
и сохранять эту информацию в отдельном свойстве `isObjectMode`. Далее, при вызове `_transform` 
мы сможем проверить в каком режиме работает наш стрим.

```js

const stream = require('stream');
const LimitExceededError = require('./LimitExceededError');

class LimitSizeStream extends stream.Transform {
  constructor(options) {
    super(options);

    this.limit = options.limit;
    this.size = 0;
    this.isObjectMode = !!options.readableObjectMode;
  }

  _transform(chunk, encoding, callback) {
    if (this.isObjectMode) {
      this.size += 1;
    } else {
      this.size += chunk.length;
    }

    if (this.size > this.limit) {
      callback(new LimitExceededError());
    } else {
      callback(null, chunk);
    }
  }
}

module.exports = LimitSizeStream;

```
